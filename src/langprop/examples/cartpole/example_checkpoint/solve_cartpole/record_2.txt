import numpy as np

def solve_cartpole(cart_position, cart_velocity, pole_angle, pole_angular_velocity) -> int:
    # Constants used in the PID controller
    Kp = 0.5
    Ki = 0.001
    Kd = 0.5

    # Constants used for mapping the controller output to an action
    zero_action = 0
    positive_action = 1

    # Define the state vector
    state = np.array([cart_position, cart_velocity, pole_angle, pole_angular_velocity])

    # Define the target state (i.e., the state we want to achieve)
    target = np.array([0, 0, 0, 0])

    # Define the bounds of the controller output
    max_output = 1.0
    min_output = -1.0

    # Define the state error and integrate it
    if 'error_sum' not in solve_cartpole.__dict__:
        solve_cartpole.error_sum = np.zeros(4)

    error = target - state
    solve_cartpole.error_sum += error
    
    # Bound the integral error to prevent accumulation
    max_error_sum = 1.0
    min_error_sum = -1.0
    solve_cartpole.error_sum = np.clip(solve_cartpole.error_sum, min_error_sum, max_error_sum)

    # Compute the controller output
    proportional = Kp * error
    integral = Ki * solve_cartpole.error_sum
    derivative = Kd * state[3]
    controller_output = np.sum(proportional + integral + derivative)
    controller_output = np.clip(controller_output, min_output, max_output)

    # Convert the controller output to an action
    if controller_output < 0:
        action = zero_action  # push the cart to the left
    else:
        action = positive_action  # push the cart to the right

    return action
